#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2018 Andriy Berestovskyy <berestovskyy@gmail.com>
#
# Bugzilla XML File to GitHub Issues Converter
#
# How to use the script:
# 1. Export Bugzilla issues into an XML file:
#    - in Bugzilla select "Search"
#    - select all statuses
#    - at the very end click an XML icon
#    - save the XML into a file
#
# 2. Generate a GitHub access token:
#    - on GitHub select "Settings"
#    - select "Developer settings"
#    - select "Personal access tokens"
#    - click "Generate new token"
#    - type a token description, i.e. "bugzilla2github"
#    - select "public_repo" to access just public repositories
#    - save the generated token
#
# 3. Run the migration script and check all the warnings:
#    bugzilla2github -x export.xml -o GITHUB_OWNER -r GITHUB_REPO -t TOKEN
#
# 4. Run the migration script again and force the updates:
#    bugzilla2github -x export.xml -o GITHUB_OWNER -r GITHUB_REPO -t TOKEN -f
#

from __future__ import absolute_import
from __future__ import print_function
import base64
import bugzilla
import json
import os
import logging
import re
import requests
import sys
import time
import xml.etree.ElementTree
from datetime import datetime, timezone
from six.moves import range
from pathlib import Path

if sys.version[0] == '2':
    reload(sys)
    sys.setdefaultencoding('utf-8')

# Script name, i.e. bugzilla2github
NAME = os.path.basename(__file__)

########################################################################
# Global variables
########################################################################

# By default use stable GitHub APIv3.
# Use -b command line argument for GitHub beta import API.
USE_BETA_API = False

# Beta import API application
GITHUB_BETA_APP = "application/vnd.github.golden-comet-preview+json"

# This signature is used to detect if the bug was imported from Bugzilla
# The signature follows with the bug id, i.e. an integer number.
BUG_SIGNATURE = "Bugzilla Bug "

DELETED_BUG_SIGNATURE = "Deleted Bugzilla Bug"

# Do the actual changes, i.e. post to GitHub
FORCE_UPDATES = False

# GitHub REST API URL
# See https://developer.github.com/v3/issues/
GITHUB_API = "https://api.github.com"

# GitHub repository owner, i.e. username
GITHUB_OWNER = None

# GitHub repository name
GITHUB_REPO = None

# GitHub access token
GITHUB_TOKEN = ""

# Bugzilla logins that were not converted to GitHub logins
UNCONVERTED_LOGINS = set()

# Global conversion dictionaries
EMAIL2LOGIN = {
    "__name__": "email to GitHub login",
    "Aaron Young": "ajyoung-oracle",
    "Aaaron.young": "ajyoung-oracle",
    "AbdulLateef Atta": "abdattar",
    "AbdulLateef.Attar": "abdattar",
    "andrei.warkentin": "andreiw",
    "Andrew Fish": "ajfish",
    "afish": "ajfish",
    "Ankit Sinha": "ankit13s",
    "ankit.sinha": "ankit13s",
    "anthony": "tperard",
    "Ard Biesheuvel": "ardbiesheuvel",
    "ard.biesheuvel": "ardbiesheuvel",
    "ardb": "ardbiesheuvel",
    "Ashraf Ali S": "AshrafAliS",
    "Aashraf.ali.s": "AshrafAliS",
    "benjamin.doron00": "benjamindoron",
    "Benny Lin": "Benny3345678",
    "benny.lin": "Benny3345678",
    "Bob Feng": "BobCF",
    "bob.c.feng": "BobCF",
    "Bret Barkelew": "corthon",
    "bret.barkelew": "corthon",
    "cbduggap": "cbduggap",
    "chinni.b.duggapu": "cbduggap",
    "Chang, Abner": "changab",
    "abner.chang": "changab",
    "Chao Li": "kilaterlee",
    "chaochao3255": "kilaterlee",
    "chao.li": "kilaterlee",
    "Chasel": "ChaselChiu",
    "chasel.chiu": "ChaselChiu",
    "Chen Yuwei": "YuweiChen1110",
    "yuwei.chen": "YuweiChen1110",
    "dandanbi": "dandanbi",
    "dandan.bi": "dandanbi",
    "Dick Wilkins": "dickwilkins",
    "dick_wilkins": "dickwilkins",
    "dong_guo@126.com": "gdong1",
    "guo.dong": "gdong1",
    "Doug Flick": "Flickdm",
    "dougflick": "Flickdm",
    "Dun Tan": "td36",
    "dun.tan": "td36",
    "Dong Wei": "dongwei67",
    "dong.wei": "dongwei67",
    "Erdem Aktas": "ruleof2",
    "erdemaktas": "ruleof2",
    "Erik Bjorge": "ErikBjorge",
    "erik.c.bjorge": "ErikBjorge",
    "Gang Chen": "chengangc",
    "gang.c.chen": "chengangc",
    "gaoliming": "lgao4",
    "gary.lin": "lcp",
    "Gerd Hoffmann": "kraxel",
    "kraxel": "kraxel",
    "Gua Guo": "gguo11837463",
    "gua.guo": "gguo11837463",
    "Igor Kulchytskyy": "igorkulchytskyy",
    "igork": "igorkulchytskyy",
    "isaac.w.oram": "iworam",
    "James Lu": "jameslu8",
    "james.lu": "jameslu8",
    "Jeremiah Cox": "out0xb2",
    "jerecox": "out0xb2",
    "Jianyong Wu": "jongwu",
    "Jjianyong.wu": "jongwu",
    "jiaxinwu": "jiaxinwu",
    "jiaxin.wu": "jiaxinwu",
    "jiewen.yao": "jyao1",
    "Joey Vagedes": "javagedes",
    "joeyvagedes": "javagedes",
    "John Mathews": "jkmathews",
    "john.mathews": "jkmathews",
    "Jordan Justen": "jljusten",
    "jordan.l.justen": "jljusten",
    "Kevin D Davis": "kevindavisinsyde",
    "kevin.davis": "kevindavisinsyde",
    "kevin.w.shaw": "kwshaw1",
    "kun.qin": "kuqin12",
    "Laszlo Ersek": "lersek",
    "laszlo.ersek": "lersek",
    "laurie": "Laurie0131",
    "Laurie Jarlstrom": "Laurie0131",
    "Leif Lindholm": "leiflindholm",
    "miki.demeter": "miki-intel-work",
    "Miki Demeter": "miki-intel-work",
    "quic_llindhol": "leiflindholm",
    "Lelia Barlow": "leliabarlow ",
    "lelia.c.barlow": "leliabarlow ",
    "Linus Liu": "LinusvPelt",
    "Llinus.liu": "LinusvPelt",
    "Marcin Wojtas": "wojtas-marcin",
    "mw": "wojtas-marcin",
    "Michael A. Rothman": "mdroth",
    "michael.a.rothman": "mdroth",
    "Michael Kinney": "mdkinney",
    "michael.d.kinney": "mdkinney",
    "Michael Kubacki": "makubacki",
    "michael.a.kubacki": "makubacki",
    "michael.kubacki": "makubacki",
    "miki.demeter": "miki-intel-work",
    "mxu9": "mxu9",
    "min.m.xu": "mxu9",
    "Nathaniel L DeSimone": "nate-desimone",
    "nathaniel.l.desimone": "nate-desimone",
    "ydong10": "ydong10",
    "eric.dong": "ydong10",
    "Nickle Wang": "nicklela",
    "nickle.wang": "nicklela",
    "Oliver Smith-Denny": "os-d",
    "osde": "os-d",
    "Paul G": "pbgrimes",
    "paul.grimes": "pbgrimes",
    "Pedro Falcato": "heatd",
    "pedro.falcato": "heatd",
    "Pierre Gondois": "pierregondois",
    "pierre.gondois": "pierregondois",
    "qiandongyan": "MarsDoge",
    "Ray Ni": "niruiyu",
    "ray.ni": "niruiyu",
    "Rebecca Cran": "bexcran",
    "rebecca": "bexcran",
    "SaiChaganty": "SaiChaganty",
    "rangasai.v.chaganty": "SaiChaganty",
    "Saloni Kasbekar": "SaloniKasbekar",
    "saloni.kasbekar": "SaloniKasbekar",
    "Sami Mujawar": "samimujawar",
    "sami.mujawar": "samimujawar",
    "Sean Brogan": "spbrogan",
    "sean.brogan": "spbrogan",
    "StarZeng": "lzeng14",
    "star.zeng": "lzeng14",
    "stephano": "cetola",
    "Stephano Cetola": "cetola",
    "Sunil V L": "vlsunil",
    "sunilvl": "vlsunil",
    "ted.kuo": "tedkuo1",
    "terry.lee": "terryplee",
    "thomas.lendacky": "tlendacky",
    "Vincent Zimmer": "vincent-j-zimmer",
    "vincent.zimmer": "vincent-j-zimmer",
    "vzimmer": "vincent-j-zimmer",
    "wei6.xu": "xuweiintel",
    "yi1.li@intel.com": "liyi77",
    "Zachary W Clark-Williams": "Zclarkwilliams",
    "zachary.clark-williams": "Zclarkwilliams",
    "zhiguang.liu": "LiuZhiguang001",
    "zhijux.fan": "zhijufan",
    "Zhiju Fan": "zhijufan",
}
STATUS2STATE = {
    "__name__": "status to GitHub state (stable APIv3)",
    "NEW": "open",
    "UNCONFIRMED": "open",
    "CONFIRMED": "open",
    "VERIFIED": "open",
    "ASSIGNED": "open",
    "IN_PROGRESS": "open",
    "RESOLVED": "closed",
    "CLOSED": "closed",
    "REOPENED": "open",
}
STATE2CLOSED_BETA = {
    "__name__": "stable API state to beta API closed",
    "open": False,
    "closed": True,
}
PRIORITY2LABELS = {
    "__name__": "priority to GitHub labels",
    "Lowest": ["priority:low"],
    "Low": ["priority:low"],
    "---": [],
    "Normal": ["priority:medium"],
    "High": ["priority:high"],
    "Highest": ["priority:high"],
}
SEVERITY2LABELS = {
    "__name__": "severity to GitHub labels",
    "enhancement": ["type:feature-request"],
    "trivial": [],
    "minor": [],
    "normal": [],
    "major": ["priority:high"],
    "critical": ["priority:high"],
    "blocker": ["priority:high"],
}
RESOLUTION2LABELS = {
    "__name__": "resolution to GitHub labels",
    "FIXED": [],
    "INVALID": ["state:invalid"],
    "DUPLICATE": ["state:duplicate"],
}
BUG_UNUSED_FIELDS = [
    "actual_time",
    "attachment.isobsolete",
    "attachment.ispatch",
    "attachment.isprivate",
    "cclist_accessible",
    "cf_documents",
    "cf_release_observed",
    "cf_releases_to_fix",
    "cf_target_os",
    "classification",
    "classification_id",
    "comment_sort_order",
    "estimated_time",
    "everconfirmed",
    "long_desc.isprivate",
    "op_sys",
    "product",
    "remaining_time",
    "reporter_accessible",
    "rep_platform",
    "target_milestone",
    "token",
    "version",
]
COMMENT_UNUSED_FIELDS = [
    "comment_count",
]
ATTACHMENT_UNUSED_FIELDS = [
    "attacher",
    "attacher.name",
    "date",
    "delta_ts",
    "token",
]


########################################################################
## GitHub API functions
########################################################################


def github_issues_add(issues):
    """
    Adds dictionary of converted issues to GitHub Issue tracker,
    i.e. this is the main script logic.

    Args:
        issues: Dictionary of issues converted from Bugzilla export.
    """
    global GITHUB_OWNER, GITHUB_REPO

    original_gh_owner = GITHUB_OWNER
    original_gh_repo = GITHUB_REPO

    id = 0
    while issues:
        id += 1
        logging.info(f"Checking if GitHub issue #{id} exists...")
        if id in issues:
            if not original_gh_owner:
                GITHUB_OWNER = issues[id]["org"]
            if not original_gh_repo:
                GITHUB_REPO = issues[id]["repo"]
        github_issue = github_issue_get(id)
        if github_issue:
            logging.warning(f"\tissue #{id} already exists on GitHub, skipping...")
            continue
        else:
            first_id = sorted(issues)[0]

            logging.info(f"\tCreating Bugzilla Bug {first_id} as GitHub issue #{id}...")
            issue = issues.pop(first_id)
            # Note: appending an issue does not guarantee it will become #id
            github_issue_add(id, issue)

    GITHUB_OWNER = original_gh_owner
    GITHUB_REPO = original_gh_repo


def github_issue_get(id):
    """
    Gets issue #id from GitHub.

    Args:
        id: GitHub #id to get.

    Returns:
        A json-encoded issue or None if issue #id does not exist on GitHub.
    """
    req = github_get("issues/%d" % id)
    if req:
        return req.json()
    else:
        return None


def github_issue_update(id, issue):
    """
    Updates issue #id on GitHub.

    Args:
        id: GitHub #id to update.
        issue: Converted Bugzilla Bug to be updated.

    Returns:
        A response object on success or exits with error otherwise.
    """
    logging.info("\tupdating issue #%d on GitHub..." % id)
    if not issue:
        logging.error("Error updating #%d: Bugzilla Bug is missing" % id)
        exit(1)

    # TODO: There is no update functionality in beta API,
    # so we use stable API to update the issue
    r = github_post("issues/%d" % id, issue,
                    ["title", "body", "state", "labels", "assignees"])
    if not r:
        logging.error("Error updating issue #%d on GitHub:\n%s" % (id, r.text))
        exit(1)


def github_issue_add_stable(id, issue):
    # Note: this still does not guarantee the new issue will be added as #id
    r = github_post("issues", issue, ["title", "body", "labels", "assignees"])

    if not r:
        logging.error("Error adding a new issue on GitHub:\n%s" % r.text)
        exit(1)

    if FORCE_UPDATES:
        # Make sure the issue is added as #id
        github_issue = github_issue_get(id)
        if not github_issue:
            logging.error("Error adding issue: issue %d does not exist" % id)
            exit(1)
        bug_id = bug_id_parse(github_issue["body"])
        if bug_id and bug_id != issue["id"]:
            logging.error("Error adding issue: issue %d is not %d"
                  % (bug_id, issue["id"]))
            exit(1)

    # Default state for the newly created issues is open, so we need to update
    # the state and the renumbering comment.
    github_issue_update(id, issue)

    return r


def github_issue_add_beta(id, issue):
    # Note: this still does not guarantee the new issue will be added as #id

    # Convert issue to beta import API
    comments = issue.pop("comments", [])
    assignees = issue.pop("assignees", [])
    if len(assignees) > 0:
        issue["assignee"] = assignees[0]
    old_id = issue.pop("id", 0)
    issue_comments = {"issue": issue, "comments": comments}

    r = github_post("import/issues", issue_comments, ["issue", "comments"])
    if not r:
        logging.error("Error importing a new issue on GitHub:\n%s" % r.text)
        exit(1)

    # Convert issue back to stable API
    issue["id"] = old_id
    issue["assignees"] = assignees

    if FORCE_UPDATES:
        # Wait until the issue is imported
        u = r.json()["url"]
        wait = 1
        r = False
        while not r or r.json()["status"] == "pending":
            time.sleep(wait)
            wait = 2 * wait
            r = github_get(u)
        if not r.json()["status"] == "imported":
            logging.error("Error importing issue on GitHub:\n%s" % r.text)
            exit(1)

        # The issue_url field of the answer should be of the form
        # .../ISSUE_NUMBER so it's easy to get the issue number,
        # to check that it is what was expected.
        result = re.match("https://api.github.com/repos/" + GITHUB_OWNER +
                          "/" + GITHUB_REPO + "/issues/(\\d+)",
                          r.json()["issue_url"])
        if not result:
            logging.error("Error while parsing issue number:\n%s" %
                  r.json()["issue_url"])
            exit(1)
        issue_number = int(result.group(1))
        if issue_number != id:
            logging.error("Error adding issue: issue %d is not %d"
                  % (issue_number, id))
            exit(1)

    # Need to update the renumbering comment
    github_issue_update(id, issue)

    return r


def github_issue_add(id, issue):
    """
    Adds issue #id to GitHub. GitHub does not allow direct issue id
    assignment, so prior to call this function, a previous issue (i.e. issue
    #id-1) MUST exist on GitHub and the issue to add (i.e. issue #id) MUST NOT
    exist on GitHub.

    Still, if someone in parallel adds an issue on GitHub, there is
    no guarantee the newly added issue will be added as #id.

    Please make sure no one else is modifying the issues at the same time
    you run this script!

    Args:
        is: GitHub #id to be added.
            Note: GitHub does not allow to add a specific #id, so this #id
                  MUST not exist on GitHub
        issue: Converted Bugzilla Bug to be added.
    """
    logging.info("\tadding a new issue #%d on GitHub..." % id)

    if USE_BETA_API:
        return github_issue_add_beta(id, issue)
    else:
        return github_issue_add_stable(id, issue)


def github_get(url):
    """
    Sends GET request to GitHub or a specified URL.

    Args:
        url: A string with an URL to get. The URL might start with:
             '/' -- the request is sent to main GitHub API URL + url string
             'http://' or 'https://' -- the request is sent to the specified url
             otherwise the request is sent to:
                GitHub API URL + /repos/ + GitHub Owner + GitHub Repo + url
        params: An optional dictionary to be sent in the query.
        headers: An optional dictionary to be sent in the headers.

    Returns:
        A response object.
    """
    if url[0] == "/":
        u = GITHUB_API + url
    elif url.startswith("https://"):
        u = url
    elif url.startswith("http://"):
        u = url
    else:
        u = "%s/repos/%s/%s/%s" % (GITHUB_API, GITHUB_OWNER, GITHUB_REPO, url)

    if USE_BETA_API:
        headers = {
            "Authorization": f"Bearer {GITHUB_TOKEN}",
            "Accept": GITHUB_BETA_APP,
        }
    else:
        headers = {
            "Authorization": f"Bearer {GITHUB_TOKEN}",
            "Accept": "application/vnd.github.v3+json",
        }

    logging.debug("DEBUG GET: " + u)
    # It's insecure to dump the token
    # logging.debug("DEBUG PARAMS: " + json.dumps(params))
    # logging.debug("DEBUG HEADERS: " + json.dumps(headers))

    return requests.get(u, headers=headers)


def github_post(url, dict={}, fields=[]):
    """
    Sends POST request to a specified URL. If global flag FORCE_UPDATES
    is not set, the function prints a warning and just returns True.

    Args:
        url: A string with an URL to post. The URL might start with:
             '/' -- the request is sent to main GitHub API URL + url string
             otherwise the request is sent to:
                GitHub API URL + /repos/ + GitHub Owner + GitHub Repo + url
        dict: An optional dictionary to be posted.
        fields: An optional list of fields to send from the dictionary.

    Returns:
        A response object. If the global flag FORCE_UPDATES is not set, always
        returns True.
    """
    if url[0] == "/":
        u = "%s%s" % (GITHUB_API, url)
    else:
        u = "%s/repos/%s/%s/%s" % (GITHUB_API, GITHUB_OWNER, GITHUB_REPO, url)

    d = {}
    # Copy fields into the data
    for field in fields:
        if field not in dict:
            logging.error("Error posting field '%s' to %s" % (field, url))
            exit(1)
        d[field] = dict[field]

    if USE_BETA_API:
        headers = {
            "Authorization": f"Bearer {GITHUB_TOKEN}",
            "Accept": GITHUB_BETA_APP,
        }
    else:
        headers = {
            "Authorization": f"Bearer {GITHUB_TOKEN}",
            "Accept": "application/vnd.github.v3+json",
        }
    data = json.dumps(d)
    logging.debug("DEBUG POST: " + u)
    logging.debug("DEBUG DATA: " + json.dumps(d))

    if FORCE_UPDATES:
        return requests.post(u, headers=headers, data=data)
    else:
        if not github_post.POST_WARNING_PRINTED:
            logging.warning("Skipping POST... (use -f to force updates)")
            github_post.POST_WARNING_PRINTED = True
        return True


# A flag if the post warning has been printed
github_post.POST_WARNING_PRINTED = False


def github_comment_add(orig_id, new_id):
    """
    Adds a comment to Github #orig_id that Bugzilla Bug is now at #new_id.

    Args:
        orig_id: Original Bugzilla Bug id.
        new_id: Newly assigned GitHub Issue #id.
    """
    logging.info("\tadding a comment to issue #%d on GitHub..." % orig_id)
    comment = new_renumber_comment(orig_id, new_id)
    r = github_post("issues/%d/comments" % orig_id, comment, ["body"])
    if not r:
        logging.error("Error adding new comment to issue #%d on GitHub:\n%s"
              % (orig_id, r.text))
        exit(1)


def github_label_create(label):
    """
    Creates a new label on GitHub.

    Args:
        label: String with new label name.
    """
    logging.info("\tcreating label '%s' on GitHub..." % label)
    r = github_post("labels", {
        "name": label,
        "color": "0"*6,
    }, ["name", "color"])
    if not r:
        logging.error("Error creating label %s: %s" % (label, r.text))
        exit(1)


def github_labels_create(issues):
    """
    Checks if all the labels assigned to all the issues are on GitHub.
    If FORCE_UPDATES flag is set, creates the missing labels.

    Args:
        issues: A dictionary of converted Bugzilla reports.
    """
    global GITHUB_OWNER, GITHUB_REPO

    original_gh_owner = GITHUB_OWNER
    original_gh_repo = GITHUB_REPO

    labels = {}
    for issue in issues.values():
        for label in issues[issue['id']]['labels']:
            if (issue['org'], issue['repo']) not in labels:
                labels[(issue['org'], issue['repo'])] = set()
            labels[(issue['org'], issue['repo'])].add(label)

    for (org, repo), curr_labels in labels.items():
        for label in curr_labels:
            if not original_gh_owner:
                GITHUB_OWNER = org
            if not original_gh_repo:
                GITHUB_REPO = repo
            if github_get("labels/" + label):
                logging.debug("\tlabel '%s' exists on GitHub" % label)
            else:
                logging.warning(f"WARNING: label '{label}' does not exist on GitHub ({GITHUB_OWNER}/{GITHUB_REPO})")
                github_label_create(label)

    GITHUB_OWNER = original_gh_owner
    GITHUB_REPO = original_gh_repo


def github_assignees_check(issues):
    """
    Checks if all the users assigned to all the issues are on GitHub.

    Args:
        issues: A dictionary of converted Bugzilla reports.
    """
    global GITHUB_OWNER, GITHUB_REPO

    original_gh_owner = GITHUB_OWNER
    original_gh_repo = GITHUB_REPO

    assignees = {}
    for issue in issues.values():
        for assignee in issues[issue['id']]['assignees']:
            if (issue['org'], issue['repo']) not in assignees:
                assignees[(issue['org'], issue['repo'])] = set()
            assignees[(issue['org'], issue['repo'])].add(assignee)

    for (org, repo), curr_assignees in assignees.items():
        for assignee in curr_assignees:
            if not original_gh_owner:
                GITHUB_OWNER = org
            if not original_gh_repo:
                GITHUB_REPO = repo
            if not github_get("/users/" + assignee):
                logging.error(f"Error checking user '{assignee}' on GitHub ({GITHUB_OWNER}/{GITHUB_REPO})")
                exit(1)
            else:
                logging.debug("\tassignee '%s' exists on GitHub" % assignee)

    GITHUB_OWNER = original_gh_owner
    GITHUB_REPO = original_gh_repo


########################################################################
## XML parsing and conversion functions
########################################################################


def XML2bug(parent):
    """
    Converts XML nodes to a new Bugzilla bug report dictionary.

    Args:
        parent: A parent XML node to start the conversion.

    Returns:
        A new dictionary containing Bugzilla bug report.
    """
    issue = {}

    logging.debug("DEBUG XML:")
    for key in parent:
        if len(key) > 0:
            logging.debug("\t> %s" % key.tag)
            val = XML2bug(key)
        else:
            val = key.text
        if key.text:
            if key.tag not in issue:
                issue[key.tag] = val
                logging.debug("\tissue['%s'] = '%s'" % (key.tag, val))
            else:
                if isinstance(issue[key.tag], list):
                    issue[key.tag].append(val)
                    logging.debug("\tissue['%s'].append('%s')" % (key.tag, val))
                else:
                    issue[key.tag] = [issue[key.tag], val]
                    logging.debug("\tissue['%s'] = [issue['%s'], '%s']" %
                              (key.tag, key.tag, val))
        # Parse attributes
        for name, val in key.items():
            issue["%s.%s" % (key.tag, name)] = val
            logging.debug("\tissue['%s.%s'] = '%s'" % (key.tag, name, val))

    return issue


def str2list(map, str):
    """Lookups in the map specific string and returns it as a list."""
    if str not in map:
        # Suppress further reports
        map[str] = []
        if map["__name__"] == "email to GitHub login":
            UNCONVERTED_LOGINS.add(str)
        else:
            logging.warning("WARNING: unable to convert %s: %s" % (map["__name__"], str))

    return map[str]


def package_to_label(*packages):
    """Converts Bugzilla package to a of GitHub label."""
    return [f"package:{p.strip().lower()}" for p in packages]


def ids2ids(ids):
    """Converts Bugzilla bug report ids to issues #ids."""
    issue = []

    if not ids:
        return ""
    if isinstance(ids, list):
        for id in ids:
            issue.append("#" + id)
    else:
        issue.append("#" + ids)

    return ", ".join(issue)


def email2login(email, name):
    """Converts email to a GitHub user login string."""
    issue = str2list(EMAIL2LOGIN, email)
    if issue:
        return "@" + issue
    else:
        if name and not name.find("@") >= 0:
            return "%s &lt;<%s>&gt;" % (name, email)
        else:
            return email


def emails2logins(emails):
    """Converts an email or a list of emails to a string."""
    issue = []
    if isinstance(emails, list):
        for email in emails:
            issue.append(email2login(email, None))
    else:
        issue.append(email2login(emails, None))
    return ", ".join(issue)


def fields_ignore(obj, fields):
    """Ignores (removes) all the fields in the objects."""
    # Ignore some Bugzilla fields
    for field in fields:
        obj.pop(field, None)


def fields_dump(obj):
    """Dumps all the fields in the object."""
    # Make sure we have converted all the fields
    for key, val in obj.items():
        logging.debug("\t%s[%d] = %s" % (key, len(val), val))


def attachment2str(idx, attach):
    """Converts Bugzilla attachment to a string."""
    issue = []

    id = attach.pop("attachid")
    issue.append("> Attached file: %s (%s, %s bytes)"
                 % (attach.pop("filename"),
                    attach.pop("type"),
                    attach.pop("size")))
    issue.append("> Description:   " + attach.pop("desc"))

    # Ignore some fields
    fields_ignore(attach, ATTACHMENT_UNUSED_FIELDS)
    # Make sure we have converted all the fields
    if attach:
        logging.warning("WARNING: unconverted attachment fields:")
        fields_dump(attach)

    idx[id] = "\n".join(issue)


def attachments2dict(attachments):
    """Converts Bugzilla attachments to a dictionary of strings."""
    issue = {}
    if isinstance(attachments, list):
        for attachment in attachments:
            attachment2str(issue, attachment)
    else:
        attachment2str(issue, attachments)

    return issue


def bugzilladate2githubdate(date):
    result = re.match(
        r'(\d\d\d\d-\d\d-\d\d) (\d\d:\d\d:\d\d) \+(\d\d)(\d\d)', date)
    if not result:
        logging.error("Date %s was not converted!" % date)
        exit(1)
    return "{a}T{b}+{c}:{d}".format(a=result.group(1), b=result.group(2),
                                    c=result.group(3), d=result.group(4))


def get_attachment_url(org_name, repo_name, attachment_id, attachment_filename):
    return f"https://github.com/tianocore/user-attachments/blob/main/{org_name}/{repo_name}/BZ-{attachment_id}-{attachment_filename}"


def comment2dict(comment, attachments, issue):
    """
    Converts Bugzilla comment to a string (stable APIv3)
    or a dictionary (beta import API).
    """
    body = []

    bug_when = comment.pop("bug_when")
    body.extend([
        "## Comment " + comment.pop("commentid"),
        "Date: " + bug_when,
        "From: " + email2login(comment.pop("who"),
                               comment.pop("who.name", None)),
        "",
        comment.pop("thetext", ""),
        "",
    ])
    # Convert attachments if any
    try:
        if "attachid" in comment:
            attach_id = comment.pop("attachid")
            attachment = next((a for a in attachments if a.get('attachid') == attach_id), None)
            if attachment:
                body.extend([
                    f"Attachment: [{attachment['filename']}]("
                    f"{get_attachment_url(issue['org'], issue['repo'], attach_id, attachment['filename'])})",
                    ""
                ])
            else:
                logging.error("Failed to convert attachment")
        body.append("")
    except KeyError:
        logging.error("Failed to convert attachment")

    # Syntax: convert "bug id" to "bug #id"
    for i, val in enumerate(body):
        if isinstance(val, dict):
            body[i] = str(val)
            body[i] = re.sub(r"(?i)(bug)\s+([0-9]+)", r"\1 #\2", str(val))

    # Ignore some comment fields
    fields_ignore(comment, COMMENT_UNUSED_FIELDS)
    # Make sure we have converted all the fields
    if comment:
        logging.warning("WARNING: unconverted comment fields:")
        fields_dump(comment)

    if USE_BETA_API:
        created_at = bugzilladate2githubdate(bug_when)
        # Return a dictionary (beta import API)
        return {"body": "\n".join(body), "created_at": created_at}
    else:
        # Return a string (stable APIv3)
        return "\n".join(body)


def comments2list(comments, attachments, issue):
    """
    Converts Bugzilla comments to a list of
    strings (stable APIv3) or dictionaries (beta import API).
    """
    comments_out = []
    if isinstance(comments, list):
        for comment in comments:
            comments_out.append(comment2dict(comment, attachments, issue))
    else:
        comments_out.append(comment2dict(comments, attachments, issue))

    return comments_out


def download_attachment(attachment_info, org, repo):
    """
    Downloads attachment from Bugzilla and saves it to a file.

    Args:
        attachment: A dictionary with attachment information.
    """
    # Save the attachment to a file
    attachment_dir = Path("user-attachments") / org / repo
    attachment_dir.mkdir(parents=True, exist_ok=True)
    attachment_file = attachment_dir / f"BZ-{attachment_info['attachid']}-{attachment_info['filename']}"

    if attachment_file.exists():
        logging.debug(f"Attachment {attachment_info['attachid']} already exists")
        # logging.info(f"Attachment {attachment_info['attachid']} already exists")
        return

    bz = bugzilla.Bugzilla("https://bugzilla.tianocore.org/rest",
                           api_key="APIKEY")

    a = bz.get_attachment(attachment_info['attachid'])
    if len(a) == 0:
        logging.error(f"Failed to download attachment {attachment_info['attachid']}")
        return

    a = a['attachments'][f"{attachment_info['attachid']}"]
    logging.info(f"Attachment for Bug {a['bug_id']} (ID = {a['id']})")
    logging.info(f"  File Name: {a['file_name']}")
    logging.info(f"  Summary: {a['summary']}")
    logging.info(f"  Creator: {a['creator']}")
    logging.info(f"  Size: {a['size']}")
    logging.info(f"  Obsolete: {"True" if a['is_obsolete'] != 0 else "False"}")

    with open(attachment_file, 'wb') as f:
        f.write(base64.b64decode(a['data']))


def bug2issue(bug):
    """
    Converts all Bugzilla report fields to a new issue dictionary.
    Dumps any unconverted fields, so all the fields must be either converted
    or listed as unused.

    Args:
        bug: A Bugzilla bug report dictionary.

    Returns:
        A new issue dictionary.
    """
    issue = new_issue(bug.pop("bug_id"), False)

    component = bug.pop("component")
    product = bug.pop("product")

    industry_spec = bug.pop("cf_industrystandardspecifications", None)
    if product == "EDK2" or product == "EDK2 Code First" or product == "Tianocore Feature Requests":
        issue["org"] = "tianocore"
        issue["repo"] = "edk2"
        if component == "Web Content":
            issue["org"] = "tianocore-docs"
            issue["repo"] = "tianocore-docs.github.io"
    elif product == "EDK2 Platforms":
        issue["org"] = "tianocore"
        issue["repo"] = "edk2=platforms"
    elif product == "EDK2 Test":
        issue["org"] = "tianocore"
        issue["repo"] = "edk2=test"
    elif product == "EDK2 Code First" and component == "Reference Implementation":
        issue["org"] = "tianocore"
        issue["repo"] = "edk2"
    elif product == "EDK2 Code First" and component == "Specification Update":
        if industry_spec == "UEFI Specification" or industry_spec == "UEFI Shell Specification":
            issue["org"] = "UEFI"
            issue["repo"] = "UEFI_spec"
        if industry_spec == "UEFI Platform Initialization Specification Specification":
            issue["org"] = "UEFI"
            issue["repo"] = "PI_Spec"
        if industry_spec == "ACPI Specification":
            issue["org"] = "UEFI"
            issue["repo"] = "ACPI_spec"
    elif product == "Tianocore Security Issues":
        logging.critical("Security issues should not be present. "
                         "The security issue should be removed and skipped.")
        exit(1)

    # Convert short_desc to title
    issue["title"] = ("%s (" % bug.pop("short_desc") + BUG_SIGNATURE
                      + "%d)" % issue["id"])
    # Convert reporter to user login
    user_login = email2login(bug.pop("reporter"),
                             bug.pop("reporter.name", None))
    # Convert assigned_to to assignees
    issue["assignees"].append(
        email2login(bug.pop("assigned_to"), bug.pop("assigned_to.name", None)))

    issue["package"] = bug.pop("cf_package", None)

    # Convert bug_status to state
    issue["state"] = str2list(STATUS2STATE, bug.pop("bug_status"))

    if USE_BETA_API:
        # Convert creation_ts to created_at
        issue["created_at"] = bugzilladate2githubdate(bug.pop("creation_ts"))
        # Convert delta_ts to updated_at
        issue["updated_at"] = bugzilladate2githubdate(bug.pop("delta_ts"))
        # Convert bug_status to closed
        issue["closed"] = str2list(STATE2CLOSED_BETA, issue["state"])
        if issue["closed"]:
            issue["closed_at"] = issue["updated_at"]
    else:
        # Convert creation_ts to created_at
        issue["created_at"] = bug.pop("creation_ts")
        # Convert delta_ts to updated_at
        issue["updated_at"] = bug.pop("delta_ts")
        issue["user.login"] = user_login

    # Convert priority to labels
    issue["labels"].extend(str2list(PRIORITY2LABELS, bug.pop("priority")))

    # Convert package to labels
    if issue["package"]:
        if isinstance(issue["package"], list):
            issue["labels"].extend(package_to_label(*issue["package"]))
        else:
            issue["labels"].extend(package_to_label(issue["package"]))

    # Convert severity to labels
    issue["labels"].extend(str2list(SEVERITY2LABELS, bug.pop("bug_severity")))

    # Convert resolution to labels
    if "resolution" in bug:
        issue["labels"].extend(
            str2list(RESOLUTION2LABELS, bug.pop("resolution")))

    # Set issue type if known
    if product == "Tianocore Feature Requests":
        issue["labels"].append("type:feature-request")
    if component == "Specification Update":
        issue["labels"].append("type:documentation-request")

    if "type:feature-request" not in issue["labels"] and "type:documentation-request" not in issue["labels"]:
        issue["labels"].append("type:bug")

    # Create the bug description
    body = []
    body.extend([
        "# " + BUG_SIGNATURE + "%d" % issue["id"],
        "Date: " + issue["created_at"],
        "From: " + user_login,
        "To:   " + ", ".join(issue["assignees"]),
    ])
    if "cc" in bug:
        body.append("CC:   " + emails2logins(bug.pop("cc")))

    # Extra information
    body.append("")
    if "dup_id" in bug:
        body.append("Duplicates:   " + ids2ids(bug.pop("dup_id")))
    if "dependson" in bug:
        body.append("Depends on:   " + ids2ids(bug.pop("dependson")))
    if "blocked" in bug:
        body.append("Blocker for:  " + ids2ids(bug.pop("blocked")))
    if "see_also" in bug:
        if isinstance(bug["see_also"], list):
            for see_also in bug.pop("see_also"):
                body.append("See also:     " + see_also)
        else:
            body.append("See also:     " + bug.pop("see_also"))
    body.append("Last updated: " + issue["updated_at"])
    body.append("")

    # Put everything together
    if USE_BETA_API:
        issue["body"] += "\n".join(body)
    else:
        issue["body"] += "\n".join(body) + "\n\n" + \
            "\n".join(issue["comments"])
    issue["assignees"] = [a[1:] for a in issue["assignees"] if a[0] == "@"]

    # Get unique labels
    labels_set = set(issue["labels"])
    issue["labels"] = list(labels_set)

    # Convert attachments if any
    attachments = []
    if "attachment" in bug:
        if isinstance(bug["attachment"], list):
            for attachment in bug["attachment"]:
                download_attachment(attachment, issue["org"], issue["repo"])
                attachments.append(attachment)
        else:
            download_attachment(bug["attachment"], issue["org"], issue["repo"])
            attachments.append(bug["attachment"])
    issue["attachments"] = attachments
    bug.pop("attachment", None)

    # Convert long_desc and attachment to comments
    issue["comments"].extend(comments2list(bug.pop("long_desc"), attachments, issue))

    logging.info(f"Bugzilla Bug #{issue['id']} (\"{issue['title']}\") mapped to {issue['org']}/{issue['repo']}")

    # Ignore some bug fields
    fields_ignore(bug, BUG_UNUSED_FIELDS)

    # Make sure we have converted all the fields
    if bug:
        logging.warning("WARNING: unconverted bug fields:")
        fields_dump(bug)

    return issue


def bugs2dict(xml_root):
    """
    Converts XML root node to a dictionary of issues.

    Args:
        xml_root: The root XML element.

    Returns:
        A new dictionary of converted Bugzilla reports.
    """
    issues = {}
    for xml_bug in xml_root.iter("bug"):
        bug = XML2bug(xml_bug)
        issue = bug2issue(bug)
        # Check for duplicates
        id = issue["id"]
        if id in issues:
            logging.error(f"Error checking duplicates: #{id} is duplicated "
                          f"in the XML file.")
        issues[id] = issue

    return issues


########################################################################
## Helper functions
########################################################################


def new_issue(id, dummy):
    """
    Creates a new issue.

    Args:
        id: The id of a new issue.
        dummy: Set True to create a new dummy issue.

    Returns:
        A dictionary representing an issue with title, body, labels, assignees,
        comments, id etc.
    """
    issue = {}
    body = []
    issue["labels"] = []
    issue["assignees"] = []
    issue["comments"] = []
    issue["id"] = int(id)
    issue["title"] = DELETED_BUG_SIGNATURE
    issue["created_at"] = datetime.now(timezone.utc).replace(microsecond=0).isoformat()
    issue["updated_at"] = issue["created_at"]
    issue["state"] = "closed"
    if USE_BETA_API:
        issue["closed"] = True
    else:
        issue["user.login"] = "bugzilla2github"

    body.extend([
        "This issue was created automatically with %s" % NAME,
        "",
    ])
    if (dummy):
        body.extend([
            "# " + DELETED_BUG_SIGNATURE,
            "Date: " + issue["created_at"],
            "",
            "This bug was created during the import from Bugzilla.",
            "GitHub Issues Tracker allows to assign consecutive",
            "ids only. So this dummy issue was created in place of",
            "a deleted Bugzilla Bug.",
            "",
            "Please ignore this report.",
            "",
        ])
    issue["body"] = "\n".join(body)

    return issue


def new_renumber_comment(orig_id, new_id):
    """
    Creates a comment to renumber Bugzilla Bug orig_id to an issue #new_id.

    Args:
        orig_id: Original Bugzilla bug id.
        new_id: New issue #id.

    Returns:
        A dictionary with comment in the "body", i.e. { "body": "comment" }
    """
    body = []
    body.extend([
        "This comment was created automatically with %s tool" % NAME,
        "## NOTE: " + BUG_SIGNATURE + "%d" % orig_id
        + " is renumbered to issue #%d" % new_id,
        "If you are looking for a Bugzilla Bug %d," % orig_id
        + " please follow issue #%d instead." % new_id,
    ])
    comment = {
        "body": "\n".join(body)
    }
    return comment


def bug_id_parse(str):
    """
    Parses Bugzilla Bug id in a string.

    Args:
        str: String to parse Bugzilla Bug id (i.e. issue body or title)

    Returns:
        Integer id, 0 for the deleted bug or None if Bug id is not found.
    """
    idx = str.find(NAME)
    if idx == -1:
        return None
    bug_id = re.search(r"(?ims)" + BUG_SIGNATURE + "([0-9]+)", str)
    if bug_id:
        return int(bug_id.group(1))
    else:
        idx = str.find(DELETED_BUG_SIGNATURE)
        if idx != -1:
            return 0  # bug_id is zero for the deleted bugs
        else:
            return None


def usage():
    """
    Displays usage information and exits.
    """
    logging.info("Bugzilla XML export file to GitHub Issues Converter")
    logging.info("Usage: %s [-b] [-h] [-f] [-d]" % NAME)
    logging.info("\t[-x <src XML file>]")
    logging.info("\t-o <GitHub owner> -r <GitHub repo> -t <GitHub access token>")
    logging.info("Where:")
    logging.info("\t-b  use GitHub beta import API")
    logging.info("\t-h  usage information")
    logging.info("\t-f  force updates (actually post the changes to GitHub)")
    logging.info("\t-d  print debug information")
    logging.info("Example:")
    logging.info("\t%s -h" % NAME)
    logging.info("\t%s -x export.xml -o github_login -r GITHUB_REPO -t token" % NAME)
    exit(1)


def parse_args() -> str:
    """
    Parses command line options and sets global variables accordingly.

    Returns:
        str: The XML file path to parse.
    """
    global FORCE_UPDATES, GITHUB_OWNER, GITHUB_REPO, GITHUB_TOKEN, USE_BETA_API

    import argparse
    from argparse import RawTextHelpFormatter

    parser = argparse.ArgumentParser(
                        prog=NAME,
                        description=(
                            "Bugzilla XML export file to GitHub Issues Converter."),
                        formatter_class=RawTextHelpFormatter)

    parser.add_argument('-b', '--beta',
                        action='store_true',
                        help="By default use stable GitHub APIv3. This uses "
                             "the GitHub beta import API.")
    parser.add_argument('-f', '--force',
                        action='store_true',
                        help="Force updates (actually post the changes to GitHub).")
    parser.add_argument('-d', '--debug',
                        action='store_true',
                        help="Print debug information.")
    parser.add_argument('-x', '--xml',
                        type=str,
                        default="export.xml",
                        help="Source XML file.")
    parser.add_argument('-o', '--owner',
                        required=False,
                        type=str,
                        default=None,
                        help="GitHub owner (overrides owner determined in the script).")
    parser.add_argument('-r', '--repo',
                        required=False,
                        type=str,
                        default=None,
                        help="GitHub repository (overrides repo determined in the script).")
    parser.add_argument('-t', '--token',
                        required=True,
                        type=str,
                        help="GitHub access token.")

    args = parser.parse_args()

    if args.beta:
        logging.warning(
            "Using GitHub beta import API. "
            "Please report issues here:\n"
            "\thttps://github.com/berestovskyy/bugzilla2github/issues"
        )
        USE_BETA_API = True

    if args.force:
        logging.warning(
            "WARNING: The repo will be UPDATED! No backups, no undos!\n"
            "Press Ctrl+C within next 5 seconds to cancel the update:"
        )
        time.sleep(5)
        FORCE_UPDATES = True

    if args.debug:
        logging.info("Debug information enabled")
        std_out_logger = logging.getLogger('stdout_logger_handler')
        std_out_logger.setLevel(logging.DEBUG)

    GITHUB_OWNER = args.owner
    GITHUB_REPO = args.repo
    GITHUB_TOKEN = args.token

    logging.info("===> Converting Bugzilla Bugs to GitHub Issues...")
    logging.info(f"\tSource XML file:          {args.xml}")
    logging.info(f"\tDestination GitHub owner: {args.owner}")
    logging.info(f"\tDestination GitHub repo:  {args.repo}")
    if args.debug:
        logging.info("\tDebug information:        on")
    if args.beta:
        logging.info("\tUsing beta import API:    on")

    return args.xml


def init_logging():
    """
    Initializes logging.
    """
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)

    stdout_logger_handler = logging.StreamHandler(sys.stdout)
    stdout_logger_handler.set_name('stdout_logger_handler')
    stdout_logger_handler.setLevel(logging.INFO)
    stdout_logger_handler.setFormatter(logging.Formatter('%(message)s'))
    root_logger.addHandler(stdout_logger_handler)


def escape_tags(content):
    return re.sub(r'(<thetext>)(.*?)(</thetext>)',
                  lambda m: f"{m.group(1)}<![CDATA[{m.group(2)}]]>{m.group(3)}",
                  content, flags=re.DOTALL)


def convert_issues_in_xml(xml_file: Path):
    with open(xml_file, 'r', encoding='utf-8') as file:
        xml_content = file.read()

    xml_tree = xml.etree.ElementTree.ElementTree(xml.etree.ElementTree.fromstring(escape_tags(xml_content)))
    xml_root = xml_tree.getroot()
    issues = bugs2dict(xml_root)

    logging.info("\n===> Checking if all the labels exist on GitHub...")
    github_labels_create(issues)
    logging.info("\n===> Checking if all the assignees exist on GitHub...")
    github_assignees_check(issues)

    logging.info("\n===> Posting Bugzilla reports to GitHub Issue Tracker...")
    github_issues_add(issues)
    logging.info("\n===> All done.")


def main():
    """
    Steps to convert Bugzilla exported bugs and post them on GitHub.
    """
    init_logging()
    xml_file_path = parse_args()
    convert_issues_in_xml(Path(xml_file_path))


if __name__ == "__main__":
    main()
